"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/books/[id]/page",{

/***/ "(app-pages-browser)/./lib/api.ts":
/*!********************!*\
  !*** ./lib/api.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   batchTranscribeChapters: function() { return /* binding */ batchTranscribeChapters; },\n/* harmony export */   deleteBook: function() { return /* binding */ deleteBook; },\n/* harmony export */   fetchBook: function() { return /* binding */ fetchBook; },\n/* harmony export */   fetchBooks: function() { return /* binding */ fetchBooks; },\n/* harmony export */   fetchChapter: function() { return /* binding */ fetchChapter; },\n/* harmony export */   fetchChapterContent: function() { return /* binding */ fetchChapterContent; },\n/* harmony export */   fetchChapters: function() { return /* binding */ fetchChapters; },\n/* harmony export */   fetchChaptersWithLexileScores: function() { return /* binding */ fetchChaptersWithLexileScores; },\n/* harmony export */   importBook: function() { return /* binding */ importBook; },\n/* harmony export */   translateText: function() { return /* binding */ translateText; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n\nconst API_BASE_URL = \"http://127.0.0.1:8081/api\";\n// const API_BASE_URL = 'https://ra.ku-m.cn/api'\nconst api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n    baseURL: API_BASE_URL,\n    timeout: 10000\n});\n// 获取书籍列表\nasync function fetchBooks() {\n    let page = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 10, sortBy = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"bookName\", direction = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"asc\";\n    const { data } = await api.get(\"/books\", {\n        params: {\n            page,\n            size,\n            sortBy,\n            direction\n        }\n    });\n    return data;\n}\n// 获取书籍详情\nasync function fetchBook(id) {\n    const { data } = await api.get(\"/books/\".concat(id));\n    return data;\n}\n// 获取章节列表\nasync function fetchChapters(bookId) {\n    let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, size = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 100, sortBy = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"chapterName\", direction = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"asc\";\n    const { data } = await api.get(\"/chapters/book/\".concat(bookId), {\n        params: {\n            page,\n            size,\n            sortBy,\n            direction\n        }\n    });\n    return data;\n}\n// 获取带有蓝思值的章节列表\nasync function fetchChaptersWithLexileScores(bookId) {\n    let page = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, size = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 100, sortBy = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : \"chapterOrder\", direction = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"asc\";\n    const { data } = await api.get(\"/chapters/book/\".concat(bookId, \"/with-lexile\"), {\n        params: {\n            page,\n            size,\n            sortBy,\n            direction\n        }\n    });\n    return data;\n}\n// 获取章节内容\nasync function fetchChapter(chapterId) {\n    let startAI = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, lexileNo = arguments.length > 2 ? arguments[2] : void 0, priorityVocabulary = arguments.length > 3 ? arguments[3] : void 0;\n    console.log(\"=== API 调用 fetchChapter 开始 ===\");\n    console.log(\"参数:\", {\n        chapterId,\n        startAI,\n        lexileNo,\n        priorityVocabulary\n    });\n    try {\n        const { data } = await api.get(\"/chapters/\".concat(chapterId), {\n            params: {\n                startAI,\n                ...lexileNo && {\n                    lexileNo\n                },\n                ...priorityVocabulary && {\n                    priorityVocabulary\n                },\n                // 添加时间戳参数，避免缓存\n                _t: Date.now()\n            }\n        });\n        console.log(\"=== API 调用 fetchChapter 成功 ===\");\n        console.log(\"返回数据:\", {\n            chapterId: data.chapterId,\n            chapterName: data.chapterName\n        });\n        return data;\n    } catch (error) {\n        console.error(\"=== API 调用 fetchChapter 失败 ===\", error);\n        throw error;\n    }\n}\n// 获取章节内容\nasync function fetchChapterContent(id) {\n    console.log(\"=== API 调用 fetchChapterContent 开始 ===\", id);\n    try {\n        const { data } = await api.get(\"/chapters/\".concat(id, \"/content\"), {\n            params: {\n                // 添加时间戳参数，避免缓存\n                _t: Date.now()\n            }\n        });\n        console.log(\"=== API 调用 fetchChapterContent 成功 ===\");\n        return data;\n    } catch (error) {\n        console.error(\"=== API 调用 fetchChapterContent 失败 ===\", error);\n        throw error;\n    }\n}\n// 批量转写章节\nasync function batchTranscribeChapters(bookId, startChapter, endChapter, lexileScore) {\n    if (!bookId) {\n        return {\n            success: false,\n            message: \"书籍ID不能为空\"\n        };\n    }\n    console.log(\"开始批量转写书籍 \".concat(bookId, \" 的章节 \").concat(startChapter, \" 到 \").concat(endChapter, \"，蓝思值: \").concat(lexileScore));\n    try {\n        // 直接发送请求，让后端处理错误情况\n        const { data } = await api.post(\"/books/\".concat(bookId, \"/batch-transcribe\"), null, {\n            params: {\n                startChapter,\n                endChapter,\n                lexileScore\n            }\n        });\n        console.log(\"批量转写响应:\", data);\n        // 如果后端返回\"该书籍没有章节\"的错误，提供更详细的指导\n        if (!data.success && data.message === \"该书籍没有章节\") {\n            return {\n                success: false,\n                message: \"该书籍没有章节。请先导入章节内容，或者检查书籍ID是否正确。\"\n            };\n        }\n        return data;\n    } catch (error) {\n        var _error_response, _error_response_data, _error_response1;\n        console.error(\"批量转写失败:\", ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data) || error.message);\n        return {\n            success: false,\n            message: ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data = _error_response1.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || \"批量转写请求失败，请稍后再试\"\n        };\n    }\n}\n// 删除书籍\nasync function deleteBook(bookId) {\n    console.log(\"删除书籍 \".concat(bookId));\n    try {\n        const { data } = await api.delete(\"/books/\".concat(bookId));\n        return data;\n    } catch (error) {\n        console.error(\"删除书籍失败:\", error);\n        return {\n            success: false,\n            message: \"删除书籍请求失败\"\n        };\n    }\n}\n// 导入书籍\nasync function importBook(bookData) {\n    try {\n        console.log(\"开始导入书籍:\", bookData.bookName, \"章节数:\", bookData.chapters.length);\n        // 转换数据格式以匹配后端 API 期望的格式\n        const requestData = {\n            bookName: bookData.bookName,\n            chapters: bookData.chapters.map((chapter)=>({\n                    chapterName: chapter.chapterName,\n                    content: chapter.content,\n                    order: chapter.order\n                }))\n        };\n        const { data } = await api.post(\"/books/import\", requestData);\n        console.log(\"导入书籍成功:\", data);\n        return {\n            success: data.success === true,\n            message: data.message || \"书籍导入成功\",\n            bookId: data.bookId\n        };\n    } catch (error) {\n        var _error_response, _error_response_data, _error_response1;\n        console.error(\"导入书籍失败:\", ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data) || error.message);\n        return {\n            success: false,\n            message: ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data = _error_response1.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || \"导入书籍失败，请稍后再试\"\n        };\n    }\n}\n// 翻译文本\nasync function translateText(text) {\n    let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"text\";\n    try {\n        const response = await api.get(\"/translate\", {\n            params: {\n                text,\n                type\n            }\n        });\n        const data = response.data;\n        return {\n            translation: data.translation && data.translation.length > 0 ? data.translation[0] : text,\n            speakUrl: data.speakUrl,\n            tSpeakUrl: data.tSpeakUrl,\n            basic: data.basic,\n            ...data\n        };\n    } catch (error) {\n        console.error(\"翻译请求失败:\", error);\n        return {\n            translation: text,\n            basic: {\n                explains: [\n                    \"翻译失败\"\n                ]\n            }\n        };\n    }\n}\n// 错误处理中间件\napi.interceptors.response.use((response)=>response, (error)=>{\n    if (error.response) {\n        // 服务器返回错误状态码\n        const { status, data } = error.response;\n        console.error(\"API Error (\".concat(status, \"):\"), data);\n    } else if (error.request) {\n        // 请求发送失败\n        console.error(\"Request Error:\", error.request);\n    } else {\n        // 请求配置错误\n        console.error(\"Error:\", error.message);\n    }\n    return Promise.reject(error);\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9hcGkudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBeUI7QUFHekIsTUFBTUMsZUFBZTtBQUNyQixnREFBZ0Q7QUFDaEQsTUFBTUMsTUFBTUYsNkNBQUtBLENBQUNHLE1BQU0sQ0FBQztJQUN2QkMsU0FBU0g7SUFDVEksU0FBUztBQUNYO0FBRUEsU0FBUztBQUNGLGVBQWVDO1FBQ3BCQyxPQUFBQSxpRUFBTyxHQUNQQyxPQUFBQSxpRUFBTyxJQUNQQyxTQUFBQSxpRUFBUyxZQUNUQyxZQUFBQSxpRUFBNEI7SUFFNUIsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBRyxNQUFNVCxJQUFJVSxHQUFHLENBQTBCLFVBQVU7UUFDaEVDLFFBQVE7WUFBRU47WUFBTUM7WUFBTUM7WUFBUUM7UUFBVTtJQUMxQztJQUNBLE9BQU9DO0FBQ1Q7QUFFQSxTQUFTO0FBQ0YsZUFBZUcsVUFBVUMsRUFBVTtJQUN4QyxNQUFNLEVBQUVKLElBQUksRUFBRSxHQUFHLE1BQU1ULElBQUlVLEdBQUcsQ0FBTyxVQUFhLE9BQUhHO0lBQy9DLE9BQU9KO0FBQ1Q7QUFFQSxTQUFTO0FBQ0YsZUFBZUssY0FDcEJDLE1BQWM7UUFDZFYsT0FBQUEsaUVBQU8sR0FDUEMsT0FBQUEsaUVBQU8sS0FDUEMsU0FBQUEsaUVBQVMsZUFDVEMsWUFBQUEsaUVBQTRCO0lBRTVCLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTVQsSUFBSVUsR0FBRyxDQUE2QixrQkFBeUIsT0FBUEssU0FBVTtRQUNyRkosUUFBUTtZQUFFTjtZQUFNQztZQUFNQztZQUFRQztRQUFVO0lBQzFDO0lBQ0EsT0FBT0M7QUFDVDtBQUVBLGVBQWU7QUFDUixlQUFlTyw4QkFDcEJELE1BQWM7UUFDZFYsT0FBQUEsaUVBQWUsR0FDZkMsT0FBQUEsaUVBQWUsS0FDZkMsU0FBQUEsaUVBQWlCLGdCQUNqQkMsWUFBQUEsaUVBQW9CO0lBYXBCLE1BQU0sRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTVQsSUFBSVUsR0FBRyxDQUFDLGtCQUF5QixPQUFQSyxRQUFPLGlCQUFlO1FBQ3JFSixRQUFRO1lBQ05OO1lBQ0FDO1lBQ0FDO1lBQ0FDO1FBQ0Y7SUFDRjtJQUNBLE9BQU9DO0FBQ1Q7QUFFQSxTQUFTO0FBQ0YsZUFBZVEsYUFDcEJDLFNBQWlCO1FBQ2pCQyxVQUFBQSxpRUFBVSxPQUNWQyx5REFDQUM7SUFFQUMsUUFBUUMsR0FBRyxDQUFDO0lBQ1pELFFBQVFDLEdBQUcsQ0FBQyxPQUFPO1FBQUVMO1FBQVdDO1FBQVNDO1FBQVVDO0lBQW1CO0lBRXRFLElBQUk7UUFDRixNQUFNLEVBQUVaLElBQUksRUFBRSxHQUFHLE1BQU1ULElBQUlVLEdBQUcsQ0FBVSxhQUF1QixPQUFWUSxZQUFhO1lBQ2hFUCxRQUFRO2dCQUNOUTtnQkFDQSxHQUFJQyxZQUFZO29CQUFFQTtnQkFBUyxDQUFDO2dCQUM1QixHQUFJQyxzQkFBc0I7b0JBQUVBO2dCQUFtQixDQUFDO2dCQUNoRCxlQUFlO2dCQUNmRyxJQUFJQyxLQUFLQyxHQUFHO1lBQ2Q7UUFDRjtRQUNBSixRQUFRQyxHQUFHLENBQUM7UUFDWkQsUUFBUUMsR0FBRyxDQUFDLFNBQVM7WUFBRUwsV0FBV1QsS0FBS1MsU0FBUztZQUFFUyxhQUFhbEIsS0FBS2tCLFdBQVc7UUFBQztRQUNoRixPQUFPbEI7SUFDVCxFQUFFLE9BQU9tQixPQUFPO1FBQ2ROLFFBQVFNLEtBQUssQ0FBQyxrQ0FBa0NBO1FBQ2hELE1BQU1BO0lBQ1I7QUFDRjtBQUVBLFNBQVM7QUFDRixlQUFlQyxvQkFBb0JoQixFQUFVO0lBQ2xEUyxRQUFRQyxHQUFHLENBQUMseUNBQXlDVjtJQUNyRCxJQUFJO1FBQ0YsTUFBTSxFQUFFSixJQUFJLEVBQUUsR0FBRyxNQUFNVCxJQUFJVSxHQUFHLENBQVMsYUFBZ0IsT0FBSEcsSUFBRyxhQUFXO1lBQ2hFRixRQUFRO2dCQUNOLGVBQWU7Z0JBQ2ZhLElBQUlDLEtBQUtDLEdBQUc7WUFDZDtRQUNGO1FBQ0FKLFFBQVFDLEdBQUcsQ0FBQztRQUNaLE9BQU9kO0lBQ1QsRUFBRSxPQUFPbUIsT0FBTztRQUNkTixRQUFRTSxLQUFLLENBQUMseUNBQXlDQTtRQUN2RCxNQUFNQTtJQUNSO0FBQ0Y7QUFFQSxTQUFTO0FBQ0YsZUFBZUUsd0JBQ3BCZixNQUFjLEVBQ2RnQixZQUFvQixFQUNwQkMsVUFBa0IsRUFDbEJDLFdBQW1CO0lBRW5CLElBQUksQ0FBQ2xCLFFBQVE7UUFDWCxPQUFPO1lBQ0xtQixTQUFTO1lBQ1RDLFNBQVM7UUFDWDtJQUNGO0lBRUFiLFFBQVFDLEdBQUcsQ0FBQyxZQUEwQlEsT0FBZGhCLFFBQU8sU0FBeUJpQixPQUFsQkQsY0FBYSxPQUF3QkUsT0FBbkJELFlBQVcsVUFBb0IsT0FBWkM7SUFDM0UsSUFBSTtRQUNGLG1CQUFtQjtRQUNuQixNQUFNLEVBQUV4QixJQUFJLEVBQUUsR0FBRyxNQUFNVCxJQUFJb0MsSUFBSSxDQUM3QixVQUFpQixPQUFQckIsUUFBTyxzQkFDakIsTUFDQTtZQUNFSixRQUFRO2dCQUNOb0I7Z0JBQ0FDO2dCQUNBQztZQUNGO1FBQ0Y7UUFHRlgsUUFBUUMsR0FBRyxDQUFDLFdBQVdkO1FBRXZCLDhCQUE4QjtRQUM5QixJQUFJLENBQUNBLEtBQUt5QixPQUFPLElBQUl6QixLQUFLMEIsT0FBTyxLQUFLLFdBQVc7WUFDL0MsT0FBTztnQkFDTEQsU0FBUztnQkFDVEMsU0FBUztZQUNYO1FBQ0Y7UUFFQSxPQUFPMUI7SUFDVCxFQUFFLE9BQU9tQixPQUFZO1lBQ01BLGlCQUdkQSxzQkFBQUE7UUFIWE4sUUFBUU0sS0FBSyxDQUFDLFdBQVdBLEVBQUFBLGtCQUFBQSxNQUFNUyxRQUFRLGNBQWRULHNDQUFBQSxnQkFBZ0JuQixJQUFJLEtBQUltQixNQUFNTyxPQUFPO1FBQzlELE9BQU87WUFDTEQsU0FBUztZQUNUQyxTQUFTUCxFQUFBQSxtQkFBQUEsTUFBTVMsUUFBUSxjQUFkVCx3Q0FBQUEsdUJBQUFBLGlCQUFnQm5CLElBQUksY0FBcEJtQiwyQ0FBQUEscUJBQXNCTyxPQUFPLEtBQUk7UUFDNUM7SUFDRjtBQUNGO0FBRUEsT0FBTztBQUNBLGVBQWVHLFdBQVd2QixNQUFjO0lBQzdDTyxRQUFRQyxHQUFHLENBQUMsUUFBZSxPQUFQUjtJQUNwQixJQUFJO1FBQ0YsTUFBTSxFQUFFTixJQUFJLEVBQUUsR0FBRyxNQUFNVCxJQUFJdUMsTUFBTSxDQUF3QyxVQUFpQixPQUFQeEI7UUFDbkYsT0FBT047SUFDVCxFQUFFLE9BQU9tQixPQUFPO1FBQ2ROLFFBQVFNLEtBQUssQ0FBQyxXQUFXQTtRQUN6QixPQUFPO1lBQUVNLFNBQVM7WUFBT0MsU0FBUztRQUFXO0lBQy9DO0FBQ0Y7QUFFQSxPQUFPO0FBQ0EsZUFBZUssV0FBV0MsUUFPaEM7SUFDQyxJQUFJO1FBQ0ZuQixRQUFRQyxHQUFHLENBQUMsV0FBV2tCLFNBQVNDLFFBQVEsRUFBRSxRQUFRRCxTQUFTRSxRQUFRLENBQUNDLE1BQU07UUFFMUUsd0JBQXdCO1FBQ3hCLE1BQU1DLGNBQWM7WUFDbEJILFVBQVVELFNBQVNDLFFBQVE7WUFDM0JDLFVBQVVGLFNBQVNFLFFBQVEsQ0FBQ0csR0FBRyxDQUFDQyxDQUFBQSxVQUFZO29CQUMxQ3BCLGFBQWFvQixRQUFRcEIsV0FBVztvQkFDaENxQixTQUFTRCxRQUFRQyxPQUFPO29CQUN4QkMsT0FBT0YsUUFBUUUsS0FBSztnQkFDdEI7UUFDRjtRQUVBLE1BQU0sRUFBRXhDLElBQUksRUFBRSxHQUFHLE1BQU1ULElBQUlvQyxJQUFJLENBQUMsaUJBQWlCUztRQUNqRHZCLFFBQVFDLEdBQUcsQ0FBQyxXQUFXZDtRQUV2QixPQUFPO1lBQ0x5QixTQUFTekIsS0FBS3lCLE9BQU8sS0FBSztZQUMxQkMsU0FBUzFCLEtBQUswQixPQUFPLElBQUk7WUFDekJwQixRQUFRTixLQUFLTSxNQUFNO1FBQ3JCO0lBQ0YsRUFBRSxPQUFPYSxPQUFZO1lBQ01BLGlCQUdkQSxzQkFBQUE7UUFIWE4sUUFBUU0sS0FBSyxDQUFDLFdBQVdBLEVBQUFBLGtCQUFBQSxNQUFNUyxRQUFRLGNBQWRULHNDQUFBQSxnQkFBZ0JuQixJQUFJLEtBQUltQixNQUFNTyxPQUFPO1FBQzlELE9BQU87WUFDTEQsU0FBUztZQUNUQyxTQUFTUCxFQUFBQSxtQkFBQUEsTUFBTVMsUUFBUSxjQUFkVCx3Q0FBQUEsdUJBQUFBLGlCQUFnQm5CLElBQUksY0FBcEJtQiwyQ0FBQUEscUJBQXNCTyxPQUFPLEtBQUk7UUFDNUM7SUFDRjtBQUNGO0FBRUEsT0FBTztBQUNBLGVBQWVlLGNBQWNDLElBQVk7UUFBRUMsT0FBQUEsaUVBQXdCO0lBVXhFLElBQUk7UUFDRixNQUFNZixXQUFXLE1BQU1yQyxJQUFJVSxHQUFHLENBUzNCLGNBQWM7WUFDZkMsUUFBUTtnQkFDTndDO2dCQUNBQztZQUNGO1FBQ0Y7UUFFQSxNQUFNM0MsT0FBTzRCLFNBQVM1QixJQUFJO1FBRTFCLE9BQU87WUFDTDRDLGFBQWE1QyxLQUFLNEMsV0FBVyxJQUFJNUMsS0FBSzRDLFdBQVcsQ0FBQ1QsTUFBTSxHQUFHLElBQUluQyxLQUFLNEMsV0FBVyxDQUFDLEVBQUUsR0FBR0Y7WUFDckZHLFVBQVU3QyxLQUFLNkMsUUFBUTtZQUN2QkMsV0FBVzlDLEtBQUs4QyxTQUFTO1lBQ3pCQyxPQUFPL0MsS0FBSytDLEtBQUs7WUFDakIsR0FBSS9DLElBQUk7UUFDVjtJQUNGLEVBQUUsT0FBT21CLE9BQU87UUFDZE4sUUFBUU0sS0FBSyxDQUFDLFdBQVdBO1FBQ3pCLE9BQU87WUFDTHlCLGFBQWFGO1lBQ2JLLE9BQU87Z0JBQ0xDLFVBQVU7b0JBQUM7aUJBQU87WUFDcEI7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxVQUFVO0FBQ1Z6RCxJQUFJMEQsWUFBWSxDQUFDckIsUUFBUSxDQUFDc0IsR0FBRyxDQUMzQixDQUFDdEIsV0FBYUEsVUFDZCxDQUFDVDtJQUNDLElBQUlBLE1BQU1TLFFBQVEsRUFBRTtRQUNsQixhQUFhO1FBQ2IsTUFBTSxFQUFFdUIsTUFBTSxFQUFFbkQsSUFBSSxFQUFFLEdBQUdtQixNQUFNUyxRQUFRO1FBQ3ZDZixRQUFRTSxLQUFLLENBQUMsY0FBcUIsT0FBUGdDLFFBQU8sT0FBS25EO0lBQzFDLE9BQU8sSUFBSW1CLE1BQU1pQyxPQUFPLEVBQUU7UUFDeEIsU0FBUztRQUNUdkMsUUFBUU0sS0FBSyxDQUFDLGtCQUFrQkEsTUFBTWlDLE9BQU87SUFDL0MsT0FBTztRQUNMLFNBQVM7UUFDVHZDLFFBQVFNLEtBQUssQ0FBQyxVQUFVQSxNQUFNTyxPQUFPO0lBQ3ZDO0lBQ0EsT0FBTzJCLFFBQVFDLE1BQU0sQ0FBQ25DO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9hcGkudHM/NjhhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnXG5pbXBvcnQgdHlwZSB7IFBhZ2luYXRlZFJlc3BvbnNlLCBCb29rLCBDaGFwdGVyIH0gZnJvbSAnQC90eXBlcydcblxuY29uc3QgQVBJX0JBU0VfVVJMID0gJ2h0dHA6Ly8xMjcuMC4wLjE6ODA4MS9hcGknXG4vLyBjb25zdCBBUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly9yYS5rdS1tLmNuL2FwaSdcbmNvbnN0IGFwaSA9IGF4aW9zLmNyZWF0ZSh7XG4gIGJhc2VVUkw6IEFQSV9CQVNFX1VSTCxcbiAgdGltZW91dDogMTAwMDAsXG59KVxuXG4vLyDojrflj5bkuabnsY3liJfooahcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEJvb2tzKFxuICBwYWdlID0gMCwgXG4gIHNpemUgPSAxMCwgXG4gIHNvcnRCeSA9ICdib29rTmFtZScsIFxuICBkaXJlY3Rpb246ICdhc2MnIHwgJ2Rlc2MnID0gJ2FzYydcbik6IFByb21pc2U8UGFnaW5hdGVkUmVzcG9uc2U8Qm9vaz4+IHtcbiAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkuZ2V0PFBhZ2luYXRlZFJlc3BvbnNlPEJvb2s+PignL2Jvb2tzJywge1xuICAgIHBhcmFtczogeyBwYWdlLCBzaXplLCBzb3J0QnksIGRpcmVjdGlvbiB9LFxuICB9KVxuICByZXR1cm4gZGF0YVxufVxuXG4vLyDojrflj5bkuabnsY3or6bmg4VcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEJvb2soaWQ6IHN0cmluZyk6IFByb21pc2U8Qm9vaz4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQ8Qm9vaz4oYC9ib29rcy8ke2lkfWApXG4gIHJldHVybiBkYXRhXG59XG5cbi8vIOiOt+WPlueroOiKguWIl+ihqFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQ2hhcHRlcnMoXG4gIGJvb2tJZDogc3RyaW5nLFxuICBwYWdlID0gMCxcbiAgc2l6ZSA9IDEwMCwgLy8g6I635Y+W5pu05aSa56ug6IqCXG4gIHNvcnRCeSA9ICdjaGFwdGVyTmFtZScsXG4gIGRpcmVjdGlvbjogJ2FzYycgfCAnZGVzYycgPSAnYXNjJ1xuKTogUHJvbWlzZTxQYWdpbmF0ZWRSZXNwb25zZTxDaGFwdGVyPj4ge1xuICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQ8UGFnaW5hdGVkUmVzcG9uc2U8Q2hhcHRlcj4+KGAvY2hhcHRlcnMvYm9vay8ke2Jvb2tJZH1gLCB7XG4gICAgcGFyYW1zOiB7IHBhZ2UsIHNpemUsIHNvcnRCeSwgZGlyZWN0aW9uIH0sXG4gIH0pXG4gIHJldHVybiBkYXRhXG59XG5cbi8vIOiOt+WPluW4puacieiTneaAneWAvOeahOeroOiKguWIl+ihqFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQ2hhcHRlcnNXaXRoTGV4aWxlU2NvcmVzKFxuICBib29rSWQ6IHN0cmluZyxcbiAgcGFnZTogbnVtYmVyID0gMCxcbiAgc2l6ZTogbnVtYmVyID0gMTAwLFxuICBzb3J0Qnk6IHN0cmluZyA9ICdjaGFwdGVyT3JkZXInLFxuICBkaXJlY3Rpb246IHN0cmluZyA9ICdhc2MnXG4pOiBQcm9taXNlPHtcbiAgY29udGVudDogQXJyYXk8e1xuICAgIGNoYXB0ZXJJZDogc3RyaW5nO1xuICAgIGNoYXB0ZXJOYW1lOiBzdHJpbmc7XG4gICAgY2hhcHRlck9yZGVyOiBudW1iZXI7XG4gICAgYXZhaWxhYmxlTGV4aWxlU2NvcmVzOiBudW1iZXJbXTtcbiAgfT47XG4gIHRvdGFsRWxlbWVudHM6IG51bWJlcjtcbiAgdG90YWxQYWdlczogbnVtYmVyO1xuICBjdXJyZW50UGFnZTogbnVtYmVyO1xuICBzaXplOiBudW1iZXI7XG59PiB7XG4gIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLmdldChgL2NoYXB0ZXJzL2Jvb2svJHtib29rSWR9L3dpdGgtbGV4aWxlYCwge1xuICAgIHBhcmFtczoge1xuICAgICAgcGFnZSxcbiAgICAgIHNpemUsXG4gICAgICBzb3J0QnksXG4gICAgICBkaXJlY3Rpb25cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLy8g6I635Y+W56ug6IqC5YaF5a65XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDaGFwdGVyKFxuICBjaGFwdGVySWQ6IHN0cmluZywgXG4gIHN0YXJ0QUkgPSBmYWxzZSwgXG4gIGxleGlsZU5vPzogbnVtYmVyLCBcbiAgcHJpb3JpdHlWb2NhYnVsYXJ5Pzogc3RyaW5nXG4pOiBQcm9taXNlPENoYXB0ZXI+IHtcbiAgY29uc29sZS5sb2coJz09PSBBUEkg6LCD55SoIGZldGNoQ2hhcHRlciDlvIDlp4sgPT09JylcbiAgY29uc29sZS5sb2coJ+WPguaVsDonLCB7IGNoYXB0ZXJJZCwgc3RhcnRBSSwgbGV4aWxlTm8sIHByaW9yaXR5Vm9jYWJ1bGFyeSB9KVxuICBcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5nZXQ8Q2hhcHRlcj4oYC9jaGFwdGVycy8ke2NoYXB0ZXJJZH1gLCB7XG4gICAgICBwYXJhbXM6IHsgXG4gICAgICAgIHN0YXJ0QUksIFxuICAgICAgICAuLi4obGV4aWxlTm8gJiYgeyBsZXhpbGVObyB9KSwgXG4gICAgICAgIC4uLihwcmlvcml0eVZvY2FidWxhcnkgJiYgeyBwcmlvcml0eVZvY2FidWxhcnkgfSksXG4gICAgICAgIC8vIOa3u+WKoOaXtumXtOaIs+WPguaVsO+8jOmBv+WFjee8k+WtmFxuICAgICAgICBfdDogRGF0ZS5ub3coKVxuICAgICAgfSxcbiAgICB9KVxuICAgIGNvbnNvbGUubG9nKCc9PT0gQVBJIOiwg+eUqCBmZXRjaENoYXB0ZXIg5oiQ5YqfID09PScpXG4gICAgY29uc29sZS5sb2coJ+i/lOWbnuaVsOaNrjonLCB7IGNoYXB0ZXJJZDogZGF0YS5jaGFwdGVySWQsIGNoYXB0ZXJOYW1lOiBkYXRhLmNoYXB0ZXJOYW1lIH0pXG4gICAgcmV0dXJuIGRhdGFcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCc9PT0gQVBJIOiwg+eUqCBmZXRjaENoYXB0ZXIg5aSx6LSlID09PScsIGVycm9yKVxuICAgIHRocm93IGVycm9yXG4gIH1cbn1cblxuLy8g6I635Y+W56ug6IqC5YaF5a65XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hDaGFwdGVyQ29udGVudChpZDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc29sZS5sb2coJz09PSBBUEkg6LCD55SoIGZldGNoQ2hhcHRlckNvbnRlbnQg5byA5aeLID09PScsIGlkKVxuICB0cnkge1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpLmdldDxzdHJpbmc+KGAvY2hhcHRlcnMvJHtpZH0vY29udGVudGAsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICAvLyDmt7vliqDml7bpl7TmiLPlj4LmlbDvvIzpgb/lhY3nvJPlrZhcbiAgICAgICAgX3Q6IERhdGUubm93KClcbiAgICAgIH1cbiAgICB9KVxuICAgIGNvbnNvbGUubG9nKCc9PT0gQVBJIOiwg+eUqCBmZXRjaENoYXB0ZXJDb250ZW50IOaIkOWKnyA9PT0nKVxuICAgIHJldHVybiBkYXRhXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignPT09IEFQSSDosIPnlKggZmV0Y2hDaGFwdGVyQ29udGVudCDlpLHotKUgPT09JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyDmibnph4/ovazlhpnnq6DoioJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBiYXRjaFRyYW5zY3JpYmVDaGFwdGVycyhcbiAgYm9va0lkOiBzdHJpbmcsXG4gIHN0YXJ0Q2hhcHRlcjogbnVtYmVyLFxuICBlbmRDaGFwdGVyOiBudW1iZXIsXG4gIGxleGlsZVNjb3JlOiBudW1iZXJcbik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfT4ge1xuICBpZiAoIWJvb2tJZCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6ICfkuabnsY1JROS4jeiDveS4uuepuidcbiAgICB9XG4gIH1cblxuICBjb25zb2xlLmxvZyhg5byA5aeL5om56YeP6L2s5YaZ5Lmm57GNICR7Ym9va0lkfSDnmoTnq6DoioIgJHtzdGFydENoYXB0ZXJ9IOWIsCAke2VuZENoYXB0ZXJ977yM6JOd5oCd5YC8OiAke2xleGlsZVNjb3JlfWApXG4gIHRyeSB7XG4gICAgLy8g55u05o6l5Y+R6YCB6K+35rGC77yM6K6p5ZCO56uv5aSE55CG6ZSZ6K+v5oOF5Ya1XG4gICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGkucG9zdDx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9PihcbiAgICAgIGAvYm9va3MvJHtib29rSWR9L2JhdGNoLXRyYW5zY3JpYmVgLFxuICAgICAgbnVsbCwgIC8vIOivt+axguS9k+S4uuepulxuICAgICAge1xuICAgICAgICBwYXJhbXM6IHsgIC8vIOS9v+eUqOafpeivouWPguaVsFxuICAgICAgICAgIHN0YXJ0Q2hhcHRlcixcbiAgICAgICAgICBlbmRDaGFwdGVyLFxuICAgICAgICAgIGxleGlsZVNjb3JlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gICAgXG4gICAgY29uc29sZS5sb2coJ+aJuemHj+i9rOWGmeWTjeW6lDonLCBkYXRhKVxuICAgIFxuICAgIC8vIOWmguaenOWQjuerr+i/lOWbnlwi6K+l5Lmm57GN5rKh5pyJ56ug6IqCXCLnmoTplJnor6/vvIzmj5Dkvpvmm7Tor6bnu4bnmoTmjIflr7xcbiAgICBpZiAoIWRhdGEuc3VjY2VzcyAmJiBkYXRhLm1lc3NhZ2UgPT09IFwi6K+l5Lmm57GN5rKh5pyJ56ug6IqCXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBtZXNzYWdlOiAn6K+l5Lmm57GN5rKh5pyJ56ug6IqC44CC6K+35YWI5a+85YWl56ug6IqC5YaF5a6577yM5oiW6ICF5qOA5p+l5Lmm57GNSUTmmK/lkKbmraPnoa7jgIInXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYXRhXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCfmibnph4/ovazlhpnlpLHotKU6JywgZXJyb3IucmVzcG9uc2U/LmRhdGEgfHwgZXJyb3IubWVzc2FnZSlcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAn5om56YeP6L2s5YaZ6K+35rGC5aSx6LSl77yM6K+356iN5ZCO5YaN6K+VJ1xuICAgIH1cbiAgfVxufVxuXG4vLyDliKDpmaTkuabnsY1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZWxldGVCb29rKGJvb2tJZDogc3RyaW5nKTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IG1lc3NhZ2U6IHN0cmluZyB9PiB7XG4gIGNvbnNvbGUubG9nKGDliKDpmaTkuabnsY0gJHtib29rSWR9YClcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5kZWxldGU8eyBzdWNjZXNzOiBib29sZWFuOyBtZXNzYWdlOiBzdHJpbmcgfT4oYC9ib29rcy8ke2Jvb2tJZH1gKVxuICAgIHJldHVybiBkYXRhXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign5Yig6Zmk5Lmm57GN5aSx6LSlOicsIGVycm9yKVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiAn5Yig6Zmk5Lmm57GN6K+35rGC5aSx6LSlJyB9XG4gIH1cbn1cblxuLy8g5a+85YWl5Lmm57GNXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0Qm9vayhib29rRGF0YToge1xuICBib29rTmFtZTogc3RyaW5nLFxuICBjaGFwdGVyczogQXJyYXk8e1xuICAgIGNoYXB0ZXJOYW1lOiBzdHJpbmcsXG4gICAgY29udGVudDogc3RyaW5nLFxuICAgIG9yZGVyOiBudW1iZXJcbiAgfT5cbn0pOiBQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgbWVzc2FnZTogc3RyaW5nOyBib29rSWQ/OiBzdHJpbmcgfT4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCflvIDlp4vlr7zlhaXkuabnsY06JywgYm9va0RhdGEuYm9va05hbWUsICfnq6DoioLmlbA6JywgYm9va0RhdGEuY2hhcHRlcnMubGVuZ3RoKVxuICAgIFxuICAgIC8vIOi9rOaNouaVsOaNruagvOW8j+S7peWMuemFjeWQjuerryBBUEkg5pyf5pyb55qE5qC85byPXG4gICAgY29uc3QgcmVxdWVzdERhdGEgPSB7XG4gICAgICBib29rTmFtZTogYm9va0RhdGEuYm9va05hbWUsXG4gICAgICBjaGFwdGVyczogYm9va0RhdGEuY2hhcHRlcnMubWFwKGNoYXB0ZXIgPT4gKHtcbiAgICAgICAgY2hhcHRlck5hbWU6IGNoYXB0ZXIuY2hhcHRlck5hbWUsXG4gICAgICAgIGNvbnRlbnQ6IGNoYXB0ZXIuY29udGVudCxcbiAgICAgICAgb3JkZXI6IGNoYXB0ZXIub3JkZXJcbiAgICAgIH0pKVxuICAgIH1cbiAgICBcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaS5wb3N0KCcvYm9va3MvaW1wb3J0JywgcmVxdWVzdERhdGEpXG4gICAgY29uc29sZS5sb2coJ+WvvOWFpeS5puexjeaIkOWKnzonLCBkYXRhKVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBkYXRhLnN1Y2Nlc3MgPT09IHRydWUsXG4gICAgICBtZXNzYWdlOiBkYXRhLm1lc3NhZ2UgfHwgJ+S5puexjeWvvOWFpeaIkOWKnycsXG4gICAgICBib29rSWQ6IGRhdGEuYm9va0lkXG4gICAgfVxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcign5a+85YWl5Lmm57GN5aSx6LSlOicsIGVycm9yLnJlc3BvbnNlPy5kYXRhIHx8IGVycm9yLm1lc3NhZ2UpXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogZXJyb3IucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgJ+WvvOWFpeS5puexjeWksei0pe+8jOivt+eojeWQjuWGjeivlSdcbiAgICB9XG4gIH1cbn1cblxuLy8g57+76K+R5paH5pysXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJhbnNsYXRlVGV4dCh0ZXh0OiBzdHJpbmcsIHR5cGU6ICd3b3JkJyB8ICd0ZXh0JyA9ICd0ZXh0Jyk6IFByb21pc2U8e1xuICB0cmFuc2xhdGlvbjogc3RyaW5nO1xuICBzcGVha1VybD86IHN0cmluZztcbiAgdFNwZWFrVXJsPzogc3RyaW5nO1xuICBiYXNpYz86IHtcbiAgICBwaG9uZXRpYz86IHN0cmluZztcbiAgICBleHBsYWluczogc3RyaW5nW107XG4gIH07XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXQ8e1xuICAgICAgdHJhbnNsYXRpb246IHN0cmluZ1tdO1xuICAgICAgYmFzaWM/OiB7XG4gICAgICAgIHBob25ldGljPzogc3RyaW5nO1xuICAgICAgICBleHBsYWluczogc3RyaW5nW107XG4gICAgICB9O1xuICAgICAgc3BlYWtVcmw/OiBzdHJpbmc7XG4gICAgICB0U3BlYWtVcmw/OiBzdHJpbmc7XG4gICAgICBba2V5OiBzdHJpbmddOiBhbnk7XG4gICAgfT4oJy90cmFuc2xhdGUnLCB7XG4gICAgICBwYXJhbXM6IHsgXG4gICAgICAgIHRleHQsIFxuICAgICAgICB0eXBlIFxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmRhdGE7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNsYXRpb246IGRhdGEudHJhbnNsYXRpb24gJiYgZGF0YS50cmFuc2xhdGlvbi5sZW5ndGggPiAwID8gZGF0YS50cmFuc2xhdGlvblswXSA6IHRleHQsXG4gICAgICBzcGVha1VybDogZGF0YS5zcGVha1VybCxcbiAgICAgIHRTcGVha1VybDogZGF0YS50U3BlYWtVcmwsXG4gICAgICBiYXNpYzogZGF0YS5iYXNpYyxcbiAgICAgIC4uLihkYXRhIGFzIG9iamVjdClcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+e/u+ivkeivt+axguWksei0pTonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zbGF0aW9uOiB0ZXh0LFxuICAgICAgYmFzaWM6IHtcbiAgICAgICAgZXhwbGFpbnM6IFsn57+76K+R5aSx6LSlJ11cbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8vIOmUmeivr+WkhOeQhuS4remXtOS7tlxuYXBpLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXG4gIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsXG4gIChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5yZXNwb25zZSkge1xuICAgICAgLy8g5pyN5Yqh5Zmo6L+U5Zue6ZSZ6K+v54q25oCB56CBXG4gICAgICBjb25zdCB7IHN0YXR1cywgZGF0YSB9ID0gZXJyb3IucmVzcG9uc2VcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEFQSSBFcnJvciAoJHtzdGF0dXN9KTpgLCBkYXRhKVxuICAgIH0gZWxzZSBpZiAoZXJyb3IucmVxdWVzdCkge1xuICAgICAgLy8g6K+35rGC5Y+R6YCB5aSx6LSlXG4gICAgICBjb25zb2xlLmVycm9yKCdSZXF1ZXN0IEVycm9yOicsIGVycm9yLnJlcXVlc3QpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIOivt+axgumFjee9rumUmeivr1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3I6JywgZXJyb3IubWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKVxuICB9XG4pICJdLCJuYW1lcyI6WyJheGlvcyIsIkFQSV9CQVNFX1VSTCIsImFwaSIsImNyZWF0ZSIsImJhc2VVUkwiLCJ0aW1lb3V0IiwiZmV0Y2hCb29rcyIsInBhZ2UiLCJzaXplIiwic29ydEJ5IiwiZGlyZWN0aW9uIiwiZGF0YSIsImdldCIsInBhcmFtcyIsImZldGNoQm9vayIsImlkIiwiZmV0Y2hDaGFwdGVycyIsImJvb2tJZCIsImZldGNoQ2hhcHRlcnNXaXRoTGV4aWxlU2NvcmVzIiwiZmV0Y2hDaGFwdGVyIiwiY2hhcHRlcklkIiwic3RhcnRBSSIsImxleGlsZU5vIiwicHJpb3JpdHlWb2NhYnVsYXJ5IiwiY29uc29sZSIsImxvZyIsIl90IiwiRGF0ZSIsIm5vdyIsImNoYXB0ZXJOYW1lIiwiZXJyb3IiLCJmZXRjaENoYXB0ZXJDb250ZW50IiwiYmF0Y2hUcmFuc2NyaWJlQ2hhcHRlcnMiLCJzdGFydENoYXB0ZXIiLCJlbmRDaGFwdGVyIiwibGV4aWxlU2NvcmUiLCJzdWNjZXNzIiwibWVzc2FnZSIsInBvc3QiLCJyZXNwb25zZSIsImRlbGV0ZUJvb2siLCJkZWxldGUiLCJpbXBvcnRCb29rIiwiYm9va0RhdGEiLCJib29rTmFtZSIsImNoYXB0ZXJzIiwibGVuZ3RoIiwicmVxdWVzdERhdGEiLCJtYXAiLCJjaGFwdGVyIiwiY29udGVudCIsIm9yZGVyIiwidHJhbnNsYXRlVGV4dCIsInRleHQiLCJ0eXBlIiwidHJhbnNsYXRpb24iLCJzcGVha1VybCIsInRTcGVha1VybCIsImJhc2ljIiwiZXhwbGFpbnMiLCJpbnRlcmNlcHRvcnMiLCJ1c2UiLCJzdGF0dXMiLCJyZXF1ZXN0IiwiUHJvbWlzZSIsInJlamVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api.ts\n"));

/***/ })

});